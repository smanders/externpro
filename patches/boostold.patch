diff --git a/boost/archive/iterators/transform_width.hpp b/boost/archive/iterators/transform_width.hpp
index 5a5c7b7..d939f93 100644
--- a/boost/archive/iterators/transform_width.hpp
+++ b/boost/archive/iterators/transform_width.hpp
@@ -30,6 +30,8 @@
 #include <boost/iterator/iterator_adaptor.hpp>
 #include <boost/iterator/iterator_traits.hpp>
 
+#include <algorithm> // std::min
+
 namespace boost { 
 namespace archive {
 namespace iterators {
diff --git a/boost/asio/detail/config.hpp b/boost/asio/detail/config.hpp
index 06d7e04..201acc4 100644
--- a/boost/asio/detail/config.hpp
+++ b/boost/asio/detail/config.hpp
@@ -333,7 +333,7 @@
 #   define BOOST_ASIO_HAS_STD_ADDRESSOF 1
 #  endif // defined(BOOST_ASIO_HAS_CLANG_LIBCXX)
 #  if defined(__GNUC__)
-#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5)) || (__GNUC__ > 4)
 #    if defined(__GXX_EXPERIMENTAL_CXX0X__)
 #     define BOOST_ASIO_HAS_STD_ADDRESSOF 1
 #    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
diff --git a/boost/config/compiler/gcc.hpp b/boost/config/compiler/gcc.hpp
index aa628e5..3c36faa 100644
--- a/boost/config/compiler/gcc.hpp
+++ b/boost/config/compiler/gcc.hpp
@@ -168,8 +168,6 @@
 #  define BOOST_NO_CXX11_CHAR16_T
 #  define BOOST_NO_CXX11_CHAR32_T
 #  define BOOST_NO_CXX11_HDR_INITIALIZER_LIST
-#  define BOOST_NO_CXX11_DEFAULTED_FUNCTIONS
-#  define BOOST_NO_CXX11_DELETED_FUNCTIONS
 #  define BOOST_NO_CXX11_TRAILING_RESULT_TYPES
 #  define BOOST_NO_CXX11_INLINE_NAMESPACES
 #endif
@@ -209,6 +207,8 @@
 #define BOOST_NO_CXX11_NULLPTR
 #define BOOST_NO_CXX11_RANGE_BASED_FOR
 #define BOOST_NO_CXX11_UNIFIED_INITIALIZATION_SYNTAX
+#define BOOST_NO_CXX11_DEFAULTED_FUNCTIONS
+#define BOOST_NO_CXX11_DELETED_FUNCTIONS
 #endif
 
 // C++0x features in 4.7.n and later
diff --git a/boost/gil/channel.hpp b/boost/gil/channel.hpp
index 823691b..1cb6b18 100644
--- a/boost/gil/channel.hpp
+++ b/boost/gil/channel.hpp
@@ -27,6 +27,7 @@
 #include <limits>
 #include <cassert>
 #include <boost/cstdint.hpp>
+#include <boost/type_traits/remove_cv.hpp>
 #include "gil_config.hpp"
 #include "utilities.hpp"
 
@@ -391,7 +392,7 @@ class packed_channel_reference<BitField,FirstBit,NumBits,false>
     typedef detail::packed_channel_reference_base<packed_channel_reference<BitField,FirstBit,NumBits,false>,BitField,NumBits,false> parent_t;
     friend class packed_channel_reference<BitField,FirstBit,NumBits,true>;
 
-    static const BitField channel_mask = static_cast< BitField >( parent_t::max_val ) << FirstBit;
+    static const BitField channel_mask = static_cast< BitField >( parent_t::max_val << FirstBit );
 
     void operator=(const packed_channel_reference&);
 public:
@@ -416,7 +417,7 @@ class packed_channel_reference<BitField,FirstBit,NumBits,true>
     typedef detail::packed_channel_reference_base<packed_channel_reference<BitField,FirstBit,NumBits,true>,BitField,NumBits,true> parent_t;
     friend class packed_channel_reference<BitField,FirstBit,NumBits,false>;
 
-    static const BitField channel_mask = static_cast< BitField >( parent_t::max_val ) << FirstBit;
+    static const BitField channel_mask = static_cast< BitField >( parent_t::max_val << FirstBit );
 
 public:
     typedef const packed_channel_reference<BitField,FirstBit,NumBits,false> const_reference;
@@ -429,6 +430,7 @@ public:
     const packed_channel_reference& operator=(integer_t value) const { assert(value<=parent_t::max_val); set_unsafe(value); return *this; }
     const packed_channel_reference& operator=(const mutable_reference& ref) const { set_from_reference(ref.get_data()); return *this; }
     const packed_channel_reference& operator=(const const_reference&   ref) const { set_from_reference(ref.get_data()); return *this; }
+    const packed_channel_reference& operator=(const packed_channel_value<NumBits>& val) const { set_unsafe(val); return *this; }
 
     template <bool Mutable1>
     const packed_channel_reference& operator=(const packed_dynamic_channel_reference<BitField,NumBits,Mutable1>& ref) const { set_unsafe(ref.get()); return *this; }
@@ -669,4 +671,30 @@ struct is_integral<gil::scoped_channel_value<BaseChannelValue,MinVal,MaxVal> > :
 
 }
 
+// \brief Determines the fundamental type which may be used, e.g., to cast from larger to smaller channel types.
+namespace boost { namespace gil {
+template <typename T>
+struct base_channel_type_impl { typedef T type; };
+
+template <int N>
+struct base_channel_type_impl<packed_channel_value<N> >
+{ typedef typename packed_channel_value<N>::integer_t type; };
+
+template <typename B, int F, int N, bool M>
+struct base_channel_type_impl<packed_channel_reference<B, F, N, M> >
+{ typedef typename packed_channel_reference<B,F,N,M>::integer_t type; };
+
+template <typename B, int N, bool M>
+struct base_channel_type_impl<packed_dynamic_channel_reference<B, N, M> >
+{ typedef typename packed_dynamic_channel_reference<B,N,M>::integer_t type; };
+
+template <typename ChannelValue, typename MinV, typename MaxV>
+struct base_channel_type_impl<scoped_channel_value<ChannelValue, MinV, MaxV> >
+{ typedef ChannelValue type; };
+
+template <typename T>
+struct base_channel_type : base_channel_type_impl<typename remove_cv<T>::type > {};
+
+} } //namespace boost::gil
+
 #endif
diff --git a/boost/gil/channel_algorithm.hpp b/boost/gil/channel_algorithm.hpp
index 1361219..98fa96a 100644
--- a/boost/gil/channel_algorithm.hpp
+++ b/boost/gil/channel_algorithm.hpp
@@ -227,7 +227,9 @@ template <typename SrcChannelV, typename DstChannelV>
 struct channel_converter_unsigned_integral_nondivisible<SrcChannelV,DstChannelV,true,false> {
     DstChannelV operator()(SrcChannelV src) const {
         typedef typename detail::min_fast_uint<unsigned_integral_num_bits<SrcChannelV>::value+unsigned_integral_num_bits<DstChannelV>::value>::type integer_t;
-        return DstChannelV(integer_t(src * unsigned_integral_max_value<DstChannelV>::value) / unsigned_integral_max_value<SrcChannelV>::value);
+        typedef typename base_channel_type<DstChannelV>::type dest_t;
+        return DstChannelV(static_cast<dest_t>(
+          integer_t(src * unsigned_integral_max_value<DstChannelV>::value) / unsigned_integral_max_value<SrcChannelV>::value));
     }
 };
 
@@ -243,22 +245,19 @@ struct channel_converter_unsigned_integral_nondivisible<SrcChannelV,DstChannelV,
     }
 };
 
+
 // Both source and destination are unsigned integral channels, 
 // the dst max value is less than (or equal to) the src max value,
 // and the src max value is not divisible by the dst max value
 template <typename SrcChannelV, typename DstChannelV, bool CannotFit> 
 struct channel_converter_unsigned_integral_nondivisible<SrcChannelV,DstChannelV,false,CannotFit> {
     DstChannelV operator()(SrcChannelV src) const { 
+        typedef typename base_channel_type<SrcChannelV>::type src_integer_t;
+        typedef typename base_channel_type<DstChannelV>::type dst_integer_t;
 
-        typedef typename detail::unsigned_integral_max_value< SrcChannelV >::value_type src_integer_t;
-        typedef typename detail::unsigned_integral_max_value< DstChannelV >::value_type dst_integer_t;
-
-        static const double div = unsigned_integral_max_value<SrcChannelV>::value 
-                                / static_cast< double >( unsigned_integral_max_value<DstChannelV>::value );
-
-        static const src_integer_t div2 = static_cast< src_integer_t >( div / 2.0 );
-
-        return DstChannelV( static_cast< dst_integer_t >(( static_cast< double >( src + div2 ) / div )));
+        static const double div = unsigned_integral_max_value<SrcChannelV>::value / double(unsigned_integral_max_value<DstChannelV>::value);
+        static const src_integer_t div2 = static_cast<src_integer_t>(div/2);
+        return DstChannelV(static_cast<dst_integer_t>((src + div2) / div));
     }
 };
 
@@ -269,10 +268,9 @@ struct channel_converter_unsigned_integral_nondivisible<SrcChannelV,DstChannelV,
 /////////////////////////////////////////////////////
 
 template <typename DstChannelV> struct channel_converter_unsigned<bits32f,DstChannelV> : public std::unary_function<bits32f,DstChannelV> {
-    DstChannelV operator()(bits32f x) const
-    {
-        typedef typename detail::unsigned_integral_max_value< DstChannelV >::value_type dst_integer_t;
-        return DstChannelV( static_cast< dst_integer_t >(x*channel_traits<DstChannelV>::max_value()+0.5f ));
+    DstChannelV   operator()(bits32f x) const {
+      typedef typename detail::unsigned_integral_max_value<DstChannelV>::value_type dst_integer_t;
+      return DstChannelV(static_cast<dst_integer_t>(x*channel_traits<DstChannelV>::max_value()+0.5f));
     }
 };
 
@@ -410,7 +408,7 @@ assert(mul == 64);    // 64 = 128 * 128 / 255
 template <typename ChannelValue>
 struct channel_multiplier_unsigned : public std::binary_function<ChannelValue,ChannelValue,ChannelValue> {
     ChannelValue operator()(ChannelValue a, ChannelValue b) const {
-        return ChannelValue(a / double(channel_traits<ChannelValue>::max_value()) * b);
+        return ChannelValue(static_cast<typename base_channel_type<ChannelValue>::type>(a / double(channel_traits<ChannelValue>::max_value()) * b));
     }
 };
 
diff --git a/boost/gil/color_convert.hpp b/boost/gil/color_convert.hpp
index 5d1da3f..eb240f8 100644
--- a/boost/gil/color_convert.hpp
+++ b/boost/gil/color_convert.hpp
@@ -223,36 +223,35 @@ struct default_color_converter_impl<cmyk_t,gray_t> {
 };
 
 namespace detail {
-template <typename Pixel> 
-typename channel_type<Pixel>::type alpha_or_max_impl(const Pixel& p, mpl::true_) {
-    return get_color(p,alpha_t());
+template <typename DstChannelRef, typename Pixel>
+void set_alpha_or_max_impl(DstChannelRef dst, const Pixel& src, mpl::true_) {
+    dst = channel_convert<DstChannelRef>(get_color(src,alpha_t()));
 }
-template <typename Pixel> 
-typename channel_type<Pixel>::type alpha_or_max_impl(const Pixel&  , mpl::false_) {
-    return channel_traits<typename channel_type<Pixel>::type>::max_value();
+template <typename DstChannelRef, typename Pixel>
+void set_alpha_or_max_impl(DstChannelRef dst, const Pixel&  , mpl::false_) {
+    dst = channel_traits<DstChannelRef>::max_value();
 }
 } // namespace detail
 
-// Returns max_value if the pixel has no alpha channel. Otherwise returns the alpha.
-template <typename Pixel> 
-typename channel_type<Pixel>::type alpha_or_max(const Pixel& p) {
-    return detail::alpha_or_max_impl(p, mpl::contains<typename color_space_type<Pixel>::type,alpha_t>());
+// Assign max_value to 'dst' if the pixel has no alpha channel. Otherwise assign the channel-converted alpha.
+template <typename DstChannelRef, typename Pixel>
+void set_alpha_or_max(DstChannelRef dst, const Pixel& src) {
+    detail::set_alpha_or_max_impl<DstChannelRef>(dst, src, contains_color<Pixel,alpha_t>());
 }
 
 
 /// \ingroup ColorConvert
-/// \brief Converting any pixel type to RGBA. Note: Supports homogeneous pixels only.
+/// \brief Converting any pixel type to RGBA.
 template <typename C1>
 struct default_color_converter_impl<C1,rgba_t> {
     template <typename P1, typename P2>
     void operator()(const P1& src, P2& dst) const {
-        typedef typename channel_type<P2>::type T2;
-        pixel<T2,rgb_layout_t> tmp;
+        P2 tmp;
         default_color_converter_impl<C1,rgb_t>()(src,tmp);
         get_color(dst,red_t())  =get_color(tmp,red_t());
         get_color(dst,green_t())=get_color(tmp,green_t());
         get_color(dst,blue_t()) =get_color(tmp,blue_t());
-        get_color(dst,alpha_t())=channel_convert<T2>(alpha_or_max(src));
+        set_alpha_or_max<typename color_element_reference_type<P2,alpha_t>::type>(get_color(dst,alpha_t()), src);
     }
 };
 
diff --git a/boost/gil/extension/numeric/affine.hpp b/boost/gil/extension/numeric/affine.hpp
new file mode 100644
index 0000000..a658c09
--- /dev/null
+++ b/boost/gil/extension/numeric/affine.hpp
@@ -0,0 +1,91 @@
+/*
+  Copyright 2005-2007 Adobe Systems Incorporated
+  Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
+  or a copy at http://opensource.adobe.com/licenses.html)
+*/
+
+/*************************************************************************************************/
+
+#ifndef GIL_AFFINE_HPP
+#define GIL_AFFINE_HPP
+
+#include "../../utilities.hpp"     // point2
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief support for affine transformations
+/// \author Lubomir Bourdev and Hailin Jin \n
+///         Adobe Systems Incorporated
+/// \date   2005-2007 \n September 21, 2006
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+namespace boost { namespace gil {
+
+////////////////////////////////////////////////////////////////////////////////////////
+///
+/// Simple matrix to do 2D affine transformations. It is actually 3x3 but the last column is [0 0 1]
+///
+////////////////////////////////////////////////////////////////////////////////////////
+template <typename T>
+class matrix3x2 {
+public:
+    matrix3x2() : a(1), b(0), c(0), d(1), e(0), f(0) {}
+    matrix3x2(T A, T B, T C, T D, T E, T F) : a(A),b(B),c(C),d(D),e(E),f(F) {}
+    matrix3x2(const matrix3x2& mat) : a(mat.a), b(mat.b), c(mat.c), d(mat.d), e(mat.e), f(mat.f) {}
+    matrix3x2& operator=(const matrix3x2& m)           { a=m.a; b=m.b; c=m.c; d=m.d; e=m.e; f=m.f; return *this; }
+
+    matrix3x2& operator*=(const matrix3x2& m)          { (*this) = (*this)*m; return *this; }
+
+    static matrix3x2 get_rotate(T rads)                { T c=std::cos(rads); T s=std::sin(rads); return matrix3x2(c,s,-s,c,0,0); }
+    static matrix3x2 get_translate(const point2<T>& t) { return matrix3x2(1  ,0,0,1  ,t.x,t.y); }
+    static matrix3x2 get_translate(T x, T y)           { return matrix3x2(1  ,0,0,1  ,x,  y  ); }
+    static matrix3x2 get_scale    (const point2<T>& s) { return matrix3x2(s.x,0,0,s.y,0  ,0  ); }
+    static matrix3x2 get_scale    (T x, T y)           { return matrix3x2(x,  0,0,y,  0  ,0  ); }
+    static matrix3x2 get_scale    (T s)                { return matrix3x2(s  ,0,0,s  ,0  ,0  ); }
+
+    T a,b,c,d,e,f;
+};
+
+template <typename T> GIL_FORCEINLINE
+matrix3x2<T> operator*(const matrix3x2<T>& m1, const matrix3x2<T>& m2) {
+    return matrix3x2<T>(
+                m1.a * m2.a + m1.b * m2.c,
+                m1.a * m2.b + m1.b * m2.d,
+                m1.c * m2.a + m1.d * m2.c,
+                m1.c * m2.b + m1.d * m2.d,
+                m1.e * m2.a + m1.f * m2.c + m2.e,
+                m1.e * m2.b + m1.f * m2.d + m2.f );
+}
+
+template <typename T, typename F> GIL_FORCEINLINE
+point2<F> operator*(const point2<T>& p, const matrix3x2<F>& m) {
+    return point2<F>(m.a*p.x + m.c*p.y + m.e, m.b*p.x + m.d*p.y + m.f);
+}
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// Define affine mapping that transforms the source coordinates by the affine transformation
+////////////////////////////////////////////////////////////////////////////////////////
+/*
+template <typename MapFn>
+concept MappingFunctionConcept {
+    typename mapping_traits<MapFn>::result_type;   where PointNDConcept<result_type>;
+
+    template <typename Domain> { where PointNDConcept<Domain> }
+    result_type transform(MapFn&, const Domain& src); 
+};
+*/
+
+template <typename T> struct mapping_traits;
+
+template <typename F>
+struct mapping_traits<matrix3x2<F> > {
+    typedef point2<F> result_type;
+};
+
+template <typename F, typename F2> GIL_FORCEINLINE
+point2<F> transform(const matrix3x2<F>& mat, const point2<F2>& src) { return src * mat; }
+
+} }  // namespace boost::gil
+
+#endif
diff --git a/boost/gil/extension/numeric/algorithm.hpp b/boost/gil/extension/numeric/algorithm.hpp
new file mode 100644
index 0000000..d847167
--- /dev/null
+++ b/boost/gil/extension/numeric/algorithm.hpp
@@ -0,0 +1,156 @@
+/*
+    Copyright 2005-2007 Adobe Systems Incorporated
+    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
+    or a copy at http://opensource.adobe.com/licenses.html)
+*/
+
+/*************************************************************************************************/
+
+#ifndef GIL_NUMERIC_ALGORITHM_HPP
+#define GIL_NUMERIC_ALGORITHM_HPP
+
+/*!
+/// \file               
+/// \brief Numeric algorithms
+/// \author Hailin Jin and Lubomir Bourdev \n
+///         Adobe Systems Incorporated
+/// \date   2005-2007 \n Last updated on February 6, 2007
+*/
+
+#include <cassert>
+#include <iterator>
+#include <algorithm>
+#include <numeric>
+#include "../../gil_config.hpp"
+#include "../../pixel_iterator.hpp"
+#include "../../metafunctions.hpp"
+
+namespace boost { namespace gil {
+
+/// \brief Returns the reference proxy associated with a type that has a \p "reference" member typedef.
+///
+/// The reference proxy is the reference type, but with stripped-out C++ reference. It models PixelConcept
+template <typename T>
+struct pixel_proxy : public remove_reference<typename T::reference> {};
+
+/// \brief std::for_each for a pair of iterators
+template <typename Iterator1,typename Iterator2,typename BinaryFunction>
+BinaryFunction for_each(Iterator1 first1,Iterator1 last1,Iterator2 first2,BinaryFunction f) {
+    while(first1!=last1)
+        f(*first1++,*first2++);
+    return f;
+}
+
+template <typename SrcIterator,typename DstIterator>
+inline DstIterator assign_pixels(SrcIterator src,SrcIterator src_end,DstIterator dst) {
+    for_each(src,src_end,dst,pixel_assigns_t<typename pixel_proxy<typename std::iterator_traits<SrcIterator>::value_type>::type,
+                                             typename pixel_proxy<typename std::iterator_traits<DstIterator>::value_type>::type>());             
+    return dst+(src_end-src);
+}
+
+namespace detail {
+template <std::size_t Size>
+struct inner_product_k_t {
+    template <class _InputIterator1, class _InputIterator2, class _Tp,
+              class _BinaryOperation1, class _BinaryOperation2>
+    static _Tp apply(_InputIterator1 __first1, 
+                     _InputIterator2 __first2, _Tp __init, 
+                     _BinaryOperation1 __binary_op1,
+                     _BinaryOperation2 __binary_op2) {
+        __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));
+        return inner_product_k_t<Size-1>::template apply(__first1+1,__first2+1,__init,
+                                                         __binary_op1, __binary_op2);
+    }
+};
+
+template <>
+struct inner_product_k_t<0> {
+    template <class _InputIterator1, class _InputIterator2, class _Tp,
+              class _BinaryOperation1, class _BinaryOperation2>
+    static _Tp apply(_InputIterator1 __first1, 
+                     _InputIterator2 __first2, _Tp __init, 
+                     _BinaryOperation1 __binary_op1,
+                     _BinaryOperation2 __binary_op2) {
+        return __init;
+    }
+};
+} // namespace detail
+
+/// static version of std::inner_product
+template <std::size_t Size,
+          class _InputIterator1, class _InputIterator2, class _Tp,
+          class _BinaryOperation1, class _BinaryOperation2>
+GIL_FORCEINLINE
+_Tp inner_product_k(_InputIterator1 __first1, 
+                    _InputIterator2 __first2,
+                    _Tp __init, 
+                    _BinaryOperation1 __binary_op1,
+                    _BinaryOperation2 __binary_op2) {
+    return detail::inner_product_k_t<Size>::template apply(__first1,__first2,__init,
+                                                           __binary_op1, __binary_op2);
+}
+
+/// \brief 1D un-guarded correlation with a variable-size kernel
+template <typename PixelAccum,typename SrcIterator,typename KernelIterator,typename Integer,typename DstIterator>
+inline DstIterator correlate_pixels_n(SrcIterator src_begin,SrcIterator src_end,
+                                      KernelIterator ker_begin,Integer ker_size,
+                                      DstIterator dst_begin) {
+    typedef typename pixel_proxy<typename std::iterator_traits<SrcIterator>::value_type>::type PIXEL_SRC_REF;
+    typedef typename pixel_proxy<typename std::iterator_traits<DstIterator>::value_type>::type PIXEL_DST_REF;
+    typedef typename std::iterator_traits<KernelIterator>::value_type kernel_type;
+    PixelAccum acc_zero; pixel_zeros_t<PixelAccum>()(acc_zero);
+    while(src_begin!=src_end) {
+        pixel_assigns_t<PixelAccum,PIXEL_DST_REF>()(
+            std::inner_product(src_begin,src_begin+ker_size,ker_begin,acc_zero,
+                               pixel_plus_t<PixelAccum,PixelAccum,PixelAccum>(),
+                               pixel_multiplies_scalar_t<PIXEL_SRC_REF,kernel_type,PixelAccum>()),
+            *dst_begin);
+        ++src_begin; ++dst_begin;
+    }
+    return dst_begin;
+}
+
+/// \brief 1D un-guarded correlation with a fixed-size kernel
+template <std::size_t Size,typename PixelAccum,typename SrcIterator,typename KernelIterator,typename DstIterator>
+inline DstIterator correlate_pixels_k(SrcIterator src_begin,SrcIterator src_end,
+                                      KernelIterator ker_begin,
+                                      DstIterator dst_begin) {
+    typedef typename pixel_proxy<typename std::iterator_traits<SrcIterator>::value_type>::type PIXEL_SRC_REF;
+    typedef typename pixel_proxy<typename std::iterator_traits<DstIterator>::value_type>::type PIXEL_DST_REF;
+    typedef typename std::iterator_traits<KernelIterator>::value_type kernel_type;
+    PixelAccum acc_zero; pixel_zeros_t<PixelAccum>()(acc_zero);
+    while(src_begin!=src_end) {
+        pixel_assigns_t<PixelAccum,PIXEL_DST_REF>()(
+            inner_product_k<Size>(src_begin,ker_begin,acc_zero,
+                                  pixel_plus_t<PixelAccum,PixelAccum,PixelAccum>(),
+                                  pixel_multiplies_scalar_t<PIXEL_SRC_REF,kernel_type,PixelAccum>()),
+            *dst_begin);
+        ++src_begin; ++dst_begin;
+    }
+    return dst_begin;
+}
+
+/// \brief destination is set to be product of the source and a scalar
+template <typename PixelAccum,typename SrcView,typename Scalar,typename DstView>
+inline void view_multiplies_scalar(const SrcView& src,const Scalar& scalar,const DstView& dst) {
+    assert(src.dimensions()==dst.dimensions());
+    typedef typename pixel_proxy<typename SrcView::value_type>::type PIXEL_SRC_REF;
+    typedef typename pixel_proxy<typename DstView::value_type>::type PIXEL_DST_REF;
+    typedef typename SrcView::y_coord_t y_coord_t;
+    y_coord_t height=src.height();
+    for(y_coord_t rr=0;rr<height;++rr) {
+        typename SrcView::x_iterator it_src=src.row_begin(rr);
+        typename DstView::x_iterator it_dst=dst.row_begin(rr);
+        typename SrcView::x_iterator it_src_end=src.row_end(rr);
+        while(it_src!=it_src_end) {
+            pixel_assigns_t<PixelAccum,PIXEL_DST_REF>()(
+                pixel_multiplies_scalar_t<PIXEL_SRC_REF,Scalar,PixelAccum>()(*it_src,scalar),
+                *it_dst);
+            ++it_src; ++it_dst;
+        }
+    }
+}
+
+} }  // namespace boost::gil
+
+#endif
diff --git a/boost/gil/extension/numeric/channel_numeric_operations.hpp b/boost/gil/extension/numeric/channel_numeric_operations.hpp
new file mode 100644
index 0000000..e823575
--- /dev/null
+++ b/boost/gil/extension/numeric/channel_numeric_operations.hpp
@@ -0,0 +1,156 @@
+/*
+    Copyright 2005-2007 Adobe Systems Incorporated
+    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
+    or a copy at http://opensource.adobe.com/licenses.html)
+*/
+
+/*************************************************************************************************/
+
+#ifndef GIL_CHANNEL_NUMERIC_OPERATIONS_HPP
+#define GIL_CHANNEL_NUMERIC_OPERATIONS_HPP
+
+/*!
+/// \file               
+/// \brief Structures for channel-wise numeric operations
+/// \author Hailin Jin and Lubomir Bourdev \n
+///         Adobe Systems Incorporated
+/// \date   2005-2007 \n Last updated on September 30, 2006
+/// Currently defined structures:
+///    channel_plus_t (+), channel_minus_t (-),
+///    channel_multiplies_t (*), channel_divides_t (/),
+///    channel_plus_scalar_t (+s), channel_minus_scalar_t (-s),
+///    channel_multiplies_scalar_t (*s), channel_divides_scalar_t (/s),
+///    channel_halves_t (/=2), channel_zeros_t (=0), channel_assigns_t (=)
+*/
+
+#include <functional>
+#include "../../gil_config.hpp"
+#include "../../channel.hpp"
+
+namespace boost { namespace gil {
+
+/// \ingroup ChannelNumericOperations
+/// structure for adding one channel to another
+/// this is a generic implementation; user should specialize it for better performance
+template <typename Channel1,typename Channel2,typename ChannelR>
+struct channel_plus_t : public std::binary_function<Channel1,Channel2,ChannelR> {
+    ChannelR operator()(typename channel_traits<Channel1>::const_reference ch1,
+                        typename channel_traits<Channel2>::const_reference ch2) const {
+        return ChannelR(ch1)+ChannelR(ch2);
+    }
+};
+
+/// \ingroup ChannelNumericOperations
+/// structure for subtracting one channel from another
+/// this is a generic implementation; user should specialize it for better performance
+template <typename Channel1,typename Channel2,typename ChannelR>
+struct channel_minus_t : public std::binary_function<Channel1,Channel2,ChannelR> {
+    ChannelR operator()(typename channel_traits<Channel1>::const_reference ch1,
+                        typename channel_traits<Channel2>::const_reference ch2) const {
+        return ChannelR(ch1)-ChannelR(ch2);
+    }
+};
+
+/// \ingroup ChannelNumericOperations
+/// structure for multiplying one channel to another
+/// this is a generic implementation; user should specialize it for better performance
+template <typename Channel1,typename Channel2,typename ChannelR>
+struct channel_multiplies_t : public std::binary_function<Channel1,Channel2,ChannelR> {
+    ChannelR operator()(typename channel_traits<Channel1>::const_reference ch1,
+                        typename channel_traits<Channel2>::const_reference ch2) const {
+        return ChannelR(ch1)*ChannelR(ch2);
+    }
+};
+
+/// \ingroup ChannelNumericOperations
+/// structure for dividing channels
+/// this is a generic implementation; user should specialize it for better performance
+template <typename Channel1,typename Channel2,typename ChannelR>
+struct channel_divides_t : public std::binary_function<Channel1,Channel2,ChannelR> {
+    ChannelR operator()(typename channel_traits<Channel1>::const_reference ch1,
+                        typename channel_traits<Channel2>::const_reference ch2) const {
+        return ChannelR(ch1)/ChannelR(ch2);
+    }
+};
+
+/// \ingroup ChannelNumericOperations
+/// structure for adding a scalar to a channel
+/// this is a generic implementation; user should specialize it for better performance
+template <typename Channel,typename Scalar,typename ChannelR>
+struct channel_plus_scalar_t : public std::binary_function<Channel,Scalar,ChannelR> {
+    ChannelR operator()(typename channel_traits<Channel>::const_reference ch,
+                        const Scalar& s) const {
+        return ChannelR(ch)+ChannelR(s);
+    }
+};
+
+/// \ingroup ChannelNumericOperations
+/// structure for subtracting a scalar from a channel
+/// this is a generic implementation; user should specialize it for better performance
+template <typename Channel,typename Scalar,typename ChannelR>
+struct channel_minus_scalar_t : public std::binary_function<Channel,Scalar,ChannelR> {
+    ChannelR operator()(typename channel_traits<Channel>::const_reference ch,
+                        const Scalar& s) const {
+        return ChannelR(ch-s);
+    }
+};
+
+/// \ingroup ChannelNumericOperations
+/// structure for multiplying a scalar to one channel
+/// this is a generic implementation; user should specialize it for better performance
+template <typename Channel,typename Scalar,typename ChannelR>
+struct channel_multiplies_scalar_t : public std::binary_function<Channel,Scalar,ChannelR> {
+    ChannelR operator()(typename channel_traits<Channel>::const_reference ch,
+                        const Scalar& s) const {
+        return ChannelR(ch)*ChannelR(s);
+    }
+};
+
+/// \ingroup ChannelNumericOperations
+/// structure for dividing a channel by a scalar
+/// this is a generic implementation; user should specialize it for better performance
+template <typename Channel,typename Scalar,typename ChannelR>
+struct channel_divides_scalar_t : public std::binary_function<Channel,Scalar,ChannelR> {
+    ChannelR operator()(typename channel_traits<Channel>::const_reference ch,
+                        const Scalar& s) const {
+        return ChannelR(ch)/ChannelR(s);
+    }
+};
+
+/// \ingroup ChannelNumericOperations
+/// structure for halving a channel
+/// this is a generic implementation; user should specialize it for better performance
+template <typename Channel>
+struct channel_halves_t : public std::unary_function<Channel,Channel> {
+    typename channel_traits<Channel>::reference
+    operator()(typename channel_traits<Channel>::reference ch) const {
+        return ch/=2.0;
+    }
+};
+
+/// \ingroup ChannelNumericOperations
+/// structure for setting a channel to zero
+/// this is a generic implementation; user should specialize it for better performance
+template <typename Channel>
+struct channel_zeros_t : public std::unary_function<Channel,Channel> {
+    typename channel_traits<Channel>::reference
+    operator()(typename channel_traits<Channel>::reference ch) const {
+        return ch=Channel(0);
+    }
+};
+
+/// \ingroup ChannelNumericOperations
+/// structure for assigning one channel to another
+/// this is a generic implementation; user should specialize it for better performance
+template <typename Channel1,typename Channel2>
+struct channel_assigns_t : public std::binary_function<Channel1,Channel2,Channel2> {
+    typename channel_traits<Channel2>::reference
+    operator()(typename channel_traits<Channel1>::const_reference ch1,
+               typename channel_traits<Channel2>::reference ch2) const {
+        return ch2=Channel2(ch1);
+    }
+};
+
+} }  // namespace boost::gil
+
+#endif
diff --git a/boost/gil/extension/numeric/convolve.hpp b/boost/gil/extension/numeric/convolve.hpp
new file mode 100644
index 0000000..24276c7
--- /dev/null
+++ b/boost/gil/extension/numeric/convolve.hpp
@@ -0,0 +1,219 @@
+/*
+    Copyright 2005-2007 Adobe Systems Incorporated
+    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
+    or a copy at http://opensource.adobe.com/licenses.html)
+*/
+
+/*************************************************************************************************/
+
+#ifndef GIL_CONVOLVE_HPP
+#define GIL_CONVOLVE_HPP
+
+/*!
+/// \file 
+/// \brief 2D seperable convolutions and correlations
+///
+/// \author Hailin Jin and Lubomir Bourdev \n
+///         Adobe Systems Incorporated
+/// \date   2005-2007 \n Last updated on February 6, 2007
+*/
+
+
+#include <cstddef>
+#include <cassert>
+#include <algorithm>
+#include <vector>
+#include <functional>
+#include "../../gil_config.hpp"
+#include "../../image_view_factory.hpp"
+#include "../../algorithm.hpp"
+#include "../../metafunctions.hpp"
+#include "pixel_numeric_operations.hpp"
+#include "algorithm.hpp"
+
+namespace boost { namespace gil {
+
+/// \ingroup ImageAlgorithms
+/// Boundary options for 1D correlations/convolutions
+enum convolve_boundary_option  {
+    convolve_option_output_ignore,  /// do nothing to the output
+    convolve_option_output_zero,    /// set the output to zero
+    convolve_option_extend_padded,  /// assume the source boundaries to be padded already 
+    convolve_option_extend_zero,    /// assume the source boundaries to be zero
+    convolve_option_extend_constant /// assume the source boundaries to be the boundary value
+};
+
+namespace detail {
+/// compute the correlation of 1D kernel with the rows of an image
+template <typename PixelAccum,typename SrcView,typename Kernel,typename DstView,typename Correlator>
+void correlate_rows_imp(const SrcView& src, const Kernel& ker, const DstView& dst,
+                        convolve_boundary_option option,
+                        Correlator correlator) {
+    assert(src.dimensions()==dst.dimensions());
+    assert(ker.size()!=0);
+
+    typedef typename pixel_proxy<typename SrcView::value_type>::type PIXEL_SRC_REF;
+    typedef typename pixel_proxy<typename DstView::value_type>::type PIXEL_DST_REF;
+    typedef typename Kernel::value_type kernel_type;
+
+    if(ker.size()==1) {//reduces to a multiplication
+        view_multiplies_scalar<PixelAccum>(src,*ker.begin(),dst);
+        return;
+    }
+
+    typedef typename SrcView::x_coord_t x_coord_t;
+    typedef typename SrcView::y_coord_t y_coord_t;
+    x_coord_t width=src.width();
+    y_coord_t height=src.height();
+    PixelAccum acc_zero; pixel_zeros_t<PixelAccum>()(acc_zero);
+    if (width==0) return;
+    if (option==convolve_option_output_ignore || option==convolve_option_output_zero) {
+        typename DstView::value_type dst_zero; pixel_assigns_t<PixelAccum,PIXEL_DST_REF>()(acc_zero,dst_zero);
+        if (width<static_cast<x_coord_t>(ker.size())) {
+            if (option==convolve_option_output_zero)
+                fill_pixels(dst,dst_zero);
+        } else {
+            std::vector<PixelAccum> buffer(width);
+            for(y_coord_t rr=0;rr<height;++rr) {
+                assign_pixels(src.row_begin(rr),src.row_end(rr),&buffer.front());
+                typename DstView::x_iterator it_dst=dst.row_begin(rr);
+                if (option==convolve_option_output_zero)
+                    std::fill_n(it_dst,ker.left_size(),dst_zero);
+                it_dst+=ker.left_size();
+                correlator(&buffer.front(),&buffer.front()+width+1-ker.size(),
+                           ker.begin(),it_dst);
+                it_dst+=width+1-ker.size();
+                if (option==convolve_option_output_zero) 
+                    std::fill_n(it_dst,ker.right_size(),dst_zero);
+            }
+        }
+    } else {
+        std::vector<PixelAccum> buffer(width+ker.size()-1);
+        for(y_coord_t rr=0;rr<height;++rr) {
+            PixelAccum* it_buffer=&buffer.front();
+            if        (option==convolve_option_extend_padded) {
+                assign_pixels(src.row_begin(rr)-ker.left_size(),
+                              src.row_end(rr)+ker.right_size(),
+                              it_buffer);
+            } else if (option==convolve_option_extend_zero) {
+                std::fill_n(it_buffer,ker.left_size(),acc_zero);
+                it_buffer+=ker.left_size();
+                assign_pixels(src.row_begin(rr),src.row_end(rr),it_buffer);
+                it_buffer+=width;
+                std::fill_n(it_buffer,ker.right_size(),acc_zero);
+            } else if (option==convolve_option_extend_constant) {
+                PixelAccum filler;
+                pixel_assigns_t<PIXEL_SRC_REF,PixelAccum>()(*src.row_begin(rr),filler);
+                std::fill_n(it_buffer,ker.left_size(),filler);
+                it_buffer+=ker.left_size();
+                assign_pixels(src.row_begin(rr),src.row_end(rr),it_buffer);
+                it_buffer+=width;
+                pixel_assigns_t<PIXEL_SRC_REF,PixelAccum>()(src.row_end(rr)[-1],filler);
+                std::fill_n(it_buffer,ker.right_size(),filler);
+            }
+            correlator(&buffer.front(),&buffer.front()+width,
+                       ker.begin(),
+                       dst.row_begin(rr));
+        }
+    }
+}
+template <typename PixelAccum>
+class correlator_n {
+private:
+    std::size_t _size;
+public:
+    correlator_n(std::size_t size_in) : _size(size_in) {}
+    template <typename SrcIterator,typename KernelIterator,typename DstIterator>
+    void operator()(SrcIterator src_begin,SrcIterator src_end,
+                    KernelIterator ker_begin,
+                    DstIterator dst_begin) {
+        correlate_pixels_n<PixelAccum>(src_begin,src_end,ker_begin,_size,dst_begin);
+    }
+};
+template <std::size_t Size,typename PixelAccum>
+struct correlator_k {
+public:
+    template <typename SrcIterator,typename KernelIterator,typename DstIterator>
+    void operator()(SrcIterator src_begin,SrcIterator src_end,
+                    KernelIterator ker_begin,
+                    DstIterator dst_begin){
+        correlate_pixels_k<Size,PixelAccum>(src_begin,src_end,ker_begin,dst_begin);
+    }
+};
+} // namespace detail
+
+/// \ingroup ImageAlgorithms
+///correlate a 1D variable-size kernel along the rows of an image
+template <typename PixelAccum,typename SrcView,typename Kernel,typename DstView>
+GIL_FORCEINLINE
+void correlate_rows(const SrcView& src, const Kernel& ker, const DstView& dst,
+                    convolve_boundary_option option=convolve_option_extend_zero) {
+    detail::correlate_rows_imp<PixelAccum>(src,ker,dst,option,detail::correlator_n<PixelAccum>(ker.size()));
+}
+
+/// \ingroup ImageAlgorithms
+///correlate a 1D variable-size kernel along the columns of an image
+template <typename PixelAccum,typename SrcView,typename Kernel,typename DstView>
+GIL_FORCEINLINE
+void correlate_cols(const SrcView& src, const Kernel& ker, const DstView& dst,
+                    convolve_boundary_option option=convolve_option_extend_zero) {
+    correlate_rows<PixelAccum>(transposed_view(src),ker,transposed_view(dst),option);
+}
+
+/// \ingroup ImageAlgorithms
+///convolve a 1D variable-size kernel along the rows of an image
+template <typename PixelAccum,typename SrcView,typename Kernel,typename DstView>
+GIL_FORCEINLINE
+void convolve_rows(const SrcView& src, const Kernel& ker, const DstView& dst,
+                   convolve_boundary_option option=convolve_option_extend_zero) {
+    correlate_rows<PixelAccum>(src,reverse_kernel(ker),dst,option);
+}
+
+/// \ingroup ImageAlgorithms
+///convolve a 1D variable-size kernel along the columns of an image
+template <typename PixelAccum,typename SrcView,typename Kernel,typename DstView>
+GIL_FORCEINLINE
+void convolve_cols(const SrcView& src, const Kernel& ker, const DstView& dst,
+                   convolve_boundary_option option=convolve_option_extend_zero) {
+    convolve_rows<PixelAccum>(transposed_view(src),ker,transposed_view(dst),option);
+}
+
+/// \ingroup ImageAlgorithms
+///correlate a 1D fixed-size kernel along the rows of an image
+template <typename PixelAccum,typename SrcView,typename Kernel,typename DstView>
+GIL_FORCEINLINE
+void correlate_rows_fixed(const SrcView& src, const Kernel& ker, const DstView& dst,
+                          convolve_boundary_option option=convolve_option_extend_zero) {
+    detail::correlate_rows_imp<PixelAccum>(src,ker,dst,option,detail::correlator_k<Kernel::static_size,PixelAccum>());
+}
+
+/// \ingroup ImageAlgorithms
+///correlate a 1D fixed-size kernel along the columns of an image
+template <typename PixelAccum,typename SrcView,typename Kernel,typename DstView>
+GIL_FORCEINLINE
+void correlate_cols_fixed(const SrcView& src, const Kernel& ker, const DstView& dst,
+                          convolve_boundary_option option=convolve_option_extend_zero) {
+    correlate_rows_fixed<PixelAccum>(transposed_view(src),ker,transposed_view(dst),option);
+}
+
+/// \ingroup ImageAlgorithms
+///convolve a 1D fixed-size kernel along the rows of an image
+template <typename PixelAccum,typename SrcView,typename Kernel,typename DstView>
+GIL_FORCEINLINE
+void convolve_rows_fixed(const SrcView& src, const Kernel& ker, const DstView& dst,
+                         convolve_boundary_option option=convolve_option_extend_zero) {
+    correlate_rows_fixed<PixelAccum>(src,reverse_kernel(ker),dst,option);
+}
+
+/// \ingroup ImageAlgorithms
+///convolve a 1D fixed-size kernel along the columns of an image
+template <typename PixelAccum,typename SrcView,typename Kernel,typename DstView>
+GIL_FORCEINLINE
+void convolve_cols_fixed(const SrcView& src, const Kernel& ker, const DstView& dst,
+                         convolve_boundary_option option=convolve_option_extend_zero) {
+    convolve_rows_fixed<PixelAccum>(transposed_view(src),ker,transposed_view(dst),option);
+}
+
+} }  // namespace boost::gil
+
+#endif
diff --git a/boost/gil/extension/numeric/kernel.hpp b/boost/gil/extension/numeric/kernel.hpp
new file mode 100644
index 0000000..f451b9b
--- /dev/null
+++ b/boost/gil/extension/numeric/kernel.hpp
@@ -0,0 +1,101 @@
+/*
+    Copyright 2005-2007 Adobe Systems Incorporated
+    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
+    or a copy at http://opensource.adobe.com/licenses.html)
+*/
+
+/*************************************************************************************************/
+
+#ifndef GIL_KERNEL_HPP
+#define GIL_KERNEL_HPP
+
+/*!
+/// \file
+/// \brief Definitions of 1D fixed-size and variable-size kernels and related operations
+/// \author Hailin Jin and Lubomir Bourdev \n
+///         Adobe Systems Incorporated
+/// \date   2005-2007 \n Last updated on September 26, 2006
+*/
+
+#include <cstddef>
+#include <cassert>
+#include <algorithm>
+#include <vector>
+#include <memory>
+#include <boost/array.hpp>
+#include "../../gil_config.hpp"
+#include "../../utilities.hpp"
+
+namespace boost { namespace gil {
+
+namespace detail {
+
+/// \brief kernel adaptor for one-dimensional cores
+/// Core needs to provide size(),begin(),end(),operator[],
+///                       value_type,iterator,const_iterator,reference,const_reference
+template <typename Core>
+class kernel_1d_adaptor : public Core {
+private:
+    std::size_t _center;
+public:
+    kernel_1d_adaptor() : _center(0) {}
+    explicit kernel_1d_adaptor(std::size_t center_in) : _center(center_in) {assert(_center<this->size());}
+    kernel_1d_adaptor(std::size_t size_in,std::size_t center_in) :
+        Core(size_in), _center(center_in) {assert(_center<this->size());}
+    kernel_1d_adaptor(const kernel_1d_adaptor& k_in) : Core(k_in), _center(k_in._center) {}
+
+    kernel_1d_adaptor& operator=(const kernel_1d_adaptor& k_in) {
+        Core::operator=(k_in);
+        _center=k_in._center;
+        return *this;
+    }
+    std::size_t left_size() const {assert(_center<this->size());return _center;}
+    std::size_t right_size() const {assert(_center<this->size());return this->size()-_center-1;}
+          std::size_t& center()       {return _center;}
+    const std::size_t& center() const {return _center;}
+};
+
+} // namespace detail
+
+/// \brief variable-size kernel
+template <typename T, typename Alloc = std::allocator<T> >
+class kernel_1d : public detail::kernel_1d_adaptor<std::vector<T,Alloc> > {
+    typedef detail::kernel_1d_adaptor<std::vector<T,Alloc> > parent_t;
+public:
+    kernel_1d() {}
+    kernel_1d(std::size_t size_in,std::size_t center_in) : parent_t(size_in,center_in) {}
+    template <typename FwdIterator>
+    kernel_1d(FwdIterator elements, std::size_t size_in, std::size_t center_in) : parent_t(size_in,center_in) {
+        detail::copy_n(elements,size_in,this->begin());
+    }
+    kernel_1d(const kernel_1d& k_in)                     : parent_t(k_in) {}
+};
+
+/// \brief static-size kernel
+template <typename T,std::size_t Size>
+class kernel_1d_fixed : public detail::kernel_1d_adaptor<array<T,Size> > {
+    typedef detail::kernel_1d_adaptor<array<T,Size> > parent_t;
+public:
+    kernel_1d_fixed() {}
+    explicit kernel_1d_fixed(std::size_t center_in) : parent_t(center_in) {}
+    
+    template <typename FwdIterator>
+    explicit kernel_1d_fixed(FwdIterator elements, std::size_t center_in) : parent_t(center_in) {
+        detail::copy_n(elements,Size,this->begin());
+    }
+    kernel_1d_fixed(const kernel_1d_fixed& k_in)    : parent_t(k_in) {}
+};
+
+/// \brief reverse a kernel
+template <typename Kernel>
+inline Kernel reverse_kernel(const Kernel& kernel) {
+    Kernel result(kernel);
+    result.center()=kernel.right_size();
+    std::reverse(result.begin(), result.end());
+    return result;
+}
+
+
+} }  // namespace boost::gil
+
+#endif
diff --git a/boost/gil/extension/numeric/pixel_numeric_operations.hpp b/boost/gil/extension/numeric/pixel_numeric_operations.hpp
new file mode 100644
index 0000000..c2829cf
--- /dev/null
+++ b/boost/gil/extension/numeric/pixel_numeric_operations.hpp
@@ -0,0 +1,144 @@
+/*
+    Copyright 2005-2007 Adobe Systems Incorporated
+    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
+    or a copy at http://opensource.adobe.com/licenses.html)
+*/
+
+/*************************************************************************************************/
+
+#ifndef GIL_PIXEL_NUMERIC_OPERATIONS_HPP
+#define GIL_PIXEL_NUMERIC_OPERATIONS_HPP
+
+/*!
+/// \file               
+/// \brief Structures for pixel-wise numeric operations
+/// \author Lubomir Bourdev and Hailin Jin \n
+///         Adobe Systems Incorporated
+/// \date   2005-2007 \n Last updated on February 6, 2007
+/// Currently defined structures:
+///     pixel_plus_t (+), pixel_minus_t (-)
+///     pixel_multiplies_scalar_t (*), pixel_divides_scalar_t (/)
+///     pixel_halves_t (/=2), pixel_zeros_t (=0)
+///     pixel_assigns_t (=)
+*/
+
+#include <functional>
+#include "../../gil_config.hpp"
+#include "../../pixel.hpp"
+#include "../../color_base_algorithm.hpp"
+#include "channel_numeric_operations.hpp"
+
+namespace boost { namespace gil {
+
+/// \ingroup PixelNumericOperations
+/// \brief construct for adding two pixels
+template <typename PixelRef1, // models pixel concept
+          typename PixelRef2, // models pixel concept
+          typename PixelR>    // models pixel value concept
+struct pixel_plus_t {
+    PixelR operator() (const PixelRef1& p1,
+                       const PixelRef2& p2) const {
+        PixelR result;
+        static_transform(p1,p2,result,
+                           channel_plus_t<typename channel_type<PixelRef1>::type,
+                                          typename channel_type<PixelRef2>::type,
+                                          typename channel_type<PixelR>::type>());
+        return result;
+    }
+};
+
+/// \ingroup PixelNumericOperations
+/// \brief construct for subtracting two pixels
+template <typename PixelRef1, // models pixel concept
+          typename PixelRef2, // models pixel concept
+          typename PixelR>    // models pixel value concept
+struct pixel_minus_t {
+    PixelR operator() (const PixelRef1& p1,
+                       const PixelRef2& p2) const {
+        PixelR result;
+        static_transform(p1,p2,result,
+                           channel_minus_t<typename channel_type<PixelRef1>::type,
+                                           typename channel_type<PixelRef2>::type,
+                                           typename channel_type<PixelR>::type>());
+        return result;
+    }
+};
+
+/// \ingroup PixelNumericOperations
+/// \brief construct for multiplying scalar to a pixel
+template <typename PixelRef, // models pixel concept
+          typename Scalar,   // models a scalar type
+          typename PixelR>   // models pixel value concept
+struct pixel_multiplies_scalar_t {
+    PixelR operator () (const PixelRef& p,
+                        const Scalar& s) const {
+        PixelR result;
+        static_transform(p,result,
+                           std::bind2nd(channel_multiplies_scalar_t<typename channel_type<PixelRef>::type,
+                                                                    Scalar,
+                                                                    typename channel_type<PixelR>::type>(),s));
+        return result;
+    }
+};
+
+/// \ingroup PixelNumericOperations
+/// \brief construct for dividing a pixel by a scalar
+template <typename PixelRef, // models pixel concept
+          typename Scalar,   // models a scalar type
+          typename PixelR>   // models pixel value concept
+struct pixel_divides_scalar_t {
+    PixelR operator () (const PixelRef& p,
+                        const Scalar& s) const {
+        PixelR result;
+        static_transform(p,result,
+                           std::bind2nd(channel_divides_scalar_t<typename channel_type<PixelRef>::type,
+                                                                 Scalar,
+                                                                 typename channel_type<PixelR>::type>(),s));
+        return result;
+    }
+};
+
+/// \ingroup PixelNumericOperations
+/// \brief construct for dividing a pixel by 2
+template <typename PixelRef> // models pixel concept
+struct pixel_halves_t {
+    PixelRef& operator () (PixelRef& p) const {
+        static_for_each(p,channel_halves_t<typename channel_type<PixelRef>::type>());
+        return p;
+    }
+};
+
+/// \ingroup PixelNumericOperations
+/// \brief construct for setting a pixel to zero (for whatever zero means)
+template <typename PixelRef> // models pixel concept
+struct pixel_zeros_t {
+    PixelRef& operator () (PixelRef& p) const {
+        static_for_each(p,channel_zeros_t<typename channel_type<PixelRef>::type>());
+        return p;
+    }
+};
+
+// Hailin: This is how you can do it:
+template <typename Pixel>
+void zero_channels(Pixel& p) {
+    static_for_each(p,channel_zeros_t<typename channel_type<Pixel>::type>());
+}
+
+
+/// \ingroup PixelNumericOperations
+///definition and a generic implementation for casting and assigning a pixel to another
+///user should specialize it for better performance
+template <typename PixelRef,  // models pixel concept
+          typename PixelRefR> // models pixel concept
+struct pixel_assigns_t {
+    PixelRefR operator () (const PixelRef& src,
+                           PixelRefR& dst) const {
+        static_for_each(src,dst,channel_assigns_t<typename channel_type<PixelRef>::type,
+                                                  typename channel_type<PixelRefR>::type>());
+        return dst;
+    }
+};
+
+} }  // namespace boost::gil
+
+#endif
diff --git a/boost/gil/extension/numeric/resample.hpp b/boost/gil/extension/numeric/resample.hpp
new file mode 100644
index 0000000..89a3099
--- /dev/null
+++ b/boost/gil/extension/numeric/resample.hpp
@@ -0,0 +1,141 @@
+/*
+  Copyright 2005-2007 Adobe Systems Incorporated
+  Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
+  or a copy at http://opensource.adobe.com/licenses.html)
+*/
+
+/*************************************************************************************************/
+
+#ifndef GIL_RESAMPLE_HPP
+#define GIL_RESAMPLE_HPP
+
+#include <boost/lambda/lambda.hpp>
+#include <boost/lambda/bind.hpp>
+#include "../../extension/dynamic_image/dynamic_image_all.hpp"
+#include "affine.hpp"
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief support for generic image resampling
+///        NOTE: The code is for example use only. It is not optimized for performance
+/// \author Lubomir Bourdev and Hailin Jin \n
+///         Adobe Systems Incorporated
+/// \date   2005-2007 \n October 30, 2006
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+namespace boost { namespace gil {
+
+///////////////////////////////////////////////////////////////////////////
+////
+////   resample_pixels: set each pixel in the destination view as the result of a sampling function over the transformed coordinates of the source view
+////
+///////////////////////////////////////////////////////////////////////////
+
+template <typename MapFn> struct mapping_traits {};
+
+/// \brief Set each pixel in the destination view as the result of a sampling function over the transformed coordinates of the source view
+/// \ingroup ImageAlgorithms
+///
+/// The provided implementation works for 2D image views only
+template <typename Sampler,        // Models SamplerConcept
+          typename SrcView,        // Models RandomAccess2DImageViewConcept
+          typename DstView,        // Models MutableRandomAccess2DImageViewConcept
+          typename MapFn>        // Models MappingFunctionConcept
+void resample_pixels(const SrcView& src_view, const DstView& dst_view, const MapFn& dst_to_src, Sampler sampler=Sampler()) {
+    typename DstView::point_t dst_dims=dst_view.dimensions();
+    typename DstView::point_t dst_p;
+    typename mapping_traits<MapFn>::result_type src_p;
+
+    for (dst_p.y=0; dst_p.y<dst_dims.y; ++dst_p.y) {
+        typename DstView::x_iterator xit = dst_view.row_begin(dst_p.y);
+        for (dst_p.x=0; dst_p.x<dst_dims.x; ++dst_p.x) {
+            sample(sampler, src_view, transform(dst_to_src, dst_p), xit[dst_p.x]);
+        }
+    }
+}
+
+///////////////////////////////////////////////////////////////////////////
+////
+////   resample_pixels when one or both image views are run-time instantiated. 
+////
+///////////////////////////////////////////////////////////////////////////
+
+namespace detail {
+    template <typename Sampler, typename MapFn>
+    struct resample_pixels_fn : public binary_operation_obj<resample_pixels_fn<Sampler,MapFn> > {
+        MapFn  _dst_to_src;
+        Sampler _sampler;
+        resample_pixels_fn(const MapFn& dst_to_src, const Sampler& sampler) : _dst_to_src(dst_to_src), _sampler(sampler) {}
+
+        template <typename SrcView, typename DstView> GIL_FORCEINLINE void apply_compatible(const SrcView& src, const DstView& dst)  const { 
+            resample_pixels(src, dst, _dst_to_src, _sampler); 
+        }
+    };
+}
+
+/// \brief resample_pixels when the source is run-time specified
+///        If invoked on incompatible views, throws std::bad_cast()
+/// \ingroup ImageAlgorithms
+template <typename Sampler, typename Types1, typename V2, typename MapFn>
+void resample_pixels(const any_image_view<Types1>& src, const V2& dst, const MapFn& dst_to_src, Sampler sampler=Sampler()) {
+    apply_operation(src,bind(detail::resample_pixels_fn<Sampler,MapFn>(dst_to_src,sampler), _1, dst));
+}
+
+/// \brief resample_pixels when the destination is run-time specified
+///        If invoked on incompatible views, throws std::bad_cast()
+/// \ingroup ImageAlgorithms
+template <typename Sampler, typename V1, typename Types2, typename MapFn>
+void resample_pixels(const V1& src, const any_image_view<Types2>& dst, const MapFn& dst_to_src, Sampler sampler=Sampler()) {
+    apply_operation(dst,bind(detail::resample_pixels_fn<Sampler,MapFn>(dst_to_src,sampler), src, _1));
+}
+
+/// \brief resample_pixels when both the source and the destination are run-time specified
+///        If invoked on incompatible views, throws std::bad_cast()
+/// \ingroup ImageAlgorithms
+template <typename Sampler, typename SrcTypes, typename DstTypes, typename MapFn> 
+void resample_pixels(const any_image_view<SrcTypes>& src, const any_image_view<DstTypes>& dst, const MapFn& dst_to_src, Sampler sampler=Sampler()) {
+    apply_operation(src,dst,detail::resample_pixels_fn<Sampler,MapFn>(dst_to_src,sampler));
+}
+
+///////////////////////////////////////////////////////////////////////////
+////
+////   resample_subimage: copy into the destination a rotated rectangular region from the source, rescaling it to fit into the destination
+////
+///////////////////////////////////////////////////////////////////////////
+
+// Extract into dst the rotated bounds [src_min..src_max] rotated at 'angle' from the source view 'src'
+// The source coordinates are in the coordinate space of the source image
+// Note that the views could also be variants (i.e. any_image_view)
+template <typename Sampler, typename SrcMetaView, typename DstMetaView> 
+void resample_subimage(const SrcMetaView& src, const DstMetaView& dst, 
+                         double src_min_x, double src_min_y,
+                         double src_max_x, double src_max_y,
+                         double angle, const Sampler& sampler=Sampler()) {
+    double src_width  = std::max<double>(src_max_x - src_min_x - 1,1);
+    double src_height = std::max<double>(src_max_y - src_min_y - 1,1);
+    double dst_width  = std::max<double>(dst.width()-1,1);
+    double dst_height = std::max<double>(dst.height()-1,1);
+
+    matrix3x2<double> mat = 
+        matrix3x2<double>::get_translate(-dst_width/2.0, -dst_height/2.0) * 
+        matrix3x2<double>::get_scale(src_width / dst_width, src_height / dst_height)*
+        matrix3x2<double>::get_rotate(-angle)*
+        matrix3x2<double>::get_translate(src_min_x + src_width/2.0, src_min_y + src_height/2.0);
+    resample_pixels(src,dst,mat,sampler);
+}
+
+///////////////////////////////////////////////////////////////////////////
+////
+////   resize_view: Copy the source view into the destination, scaling to fit
+////
+///////////////////////////////////////////////////////////////////////////
+
+template <typename Sampler, typename SrcMetaView, typename DstMetaView> 
+void resize_view(const SrcMetaView& src, const DstMetaView& dst, const Sampler& sampler=Sampler()) {
+    resample_subimage(src,dst,0,0,src.width(),src.height(),0,sampler);
+}
+
+} }  // namespace boost::gil
+
+#endif
diff --git a/boost/gil/extension/numeric/sampler.hpp b/boost/gil/extension/numeric/sampler.hpp
new file mode 100644
index 0000000..841b470
--- /dev/null
+++ b/boost/gil/extension/numeric/sampler.hpp
@@ -0,0 +1,146 @@
+/*
+  Copyright 2005-2007 Adobe Systems Incorporated
+  Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
+  or a copy at http://opensource.adobe.com/licenses.html)
+*/
+
+/*************************************************************************************************/
+
+#ifndef GIL_SAMPLER_HPP
+#define GIL_SAMPLER_HPP
+
+#include "../../extension/dynamic_image/dynamic_image_all.hpp"
+#include "pixel_numeric_operations.hpp"
+
+////////////////////////////////////////////////////////////////////////////////////////
+/// \file               
+/// \brief Nearest-neighbor and bilinear image samplers.
+///        NOTE: The code is for example use only. It is not optimized for performance
+/// \author Lubomir Bourdev and Hailin Jin \n
+///         Adobe Systems Incorporated
+/// \date   2005-2007 \n October 30, 2006
+///
+////////////////////////////////////////////////////////////////////////////////////////
+
+namespace boost { namespace gil {
+
+///////////////////////////////////////////////////////////////////////////
+////
+////     resample_pixels: set each pixel in the destination view as the result of a sampling function over the transformed coordinates of the source view
+////
+///////////////////////////////////////////////////////////////////////////
+/*
+template <typename Sampler>
+concept SamplerConcept {
+    template <typename DstP,      // Models PixelConcept
+              typename SrcView,    // Models RandomAccessNDImageViewConcept
+              typename S_COORDS>  // Models PointNDConcept, where S_COORDS::num_dimensions == SrcView::num_dimensions
+    bool sample(const Sampler& s, const SrcView& src, const S_COORDS& p, DstP result);
+};
+*/
+
+/// \brief A sampler that sets the destination pixel to the closest one in the source. If outside the bounds, it doesn't change the destination
+/// \ingroup ImageAlgorithms
+struct nearest_neighbor_sampler {};
+
+template <typename DstP, typename SrcView, typename F>
+bool sample(nearest_neighbor_sampler, const SrcView& src, const point2<F>& p, DstP& result) {
+    point2<std::ptrdiff_t> center(iround(p));
+    if (center.x>=0 && center.y>=0 && center.x<src.width() && center.y<src.height()) {
+        result=src(center.x,center.y);
+        return true;
+    }
+    return false;
+}
+
+struct cast_channel_fn {
+    template <typename SrcChannel, typename DstChannel>
+    void operator()(const SrcChannel& src, DstChannel& dst) {
+        typedef typename channel_traits<DstChannel>::value_type dst_value_t;
+        dst = dst_value_t(src);
+    }
+};
+
+template <typename SrcPixel, typename DstPixel>
+void cast_pixel(const SrcPixel& src, DstPixel& dst) {
+    static_for_each(src,dst,cast_channel_fn());
+}
+
+namespace detail {
+
+template <typename Weight>
+struct add_dst_mul_src_channel {
+    Weight _w;
+    add_dst_mul_src_channel(Weight w) : _w(w) {}
+
+    template <typename SrcChannel, typename DstChannel>
+    void operator()(const SrcChannel& src, DstChannel& dst) const {
+        dst += DstChannel(src*_w);
+    }
+};
+
+// dst += DST_TYPE(src * w)
+template <typename SrcP,typename Weight,typename DstP>
+struct add_dst_mul_src {
+    void operator()(const SrcP& src, Weight weight, DstP& dst) const {
+        static_for_each(src,dst, add_dst_mul_src_channel<Weight>(weight));
+//        pixel_assigns_t<DstP,DstP&>()(
+//            pixel_plus_t<DstP,DstP,DstP>()(
+//                pixel_multiplies_scalar_t<SrcP,Weight,DstP>()(src,weight),
+//                dst),
+//            dst);
+    }
+};
+} // namespace detail
+
+/// \brief A sampler that sets the destination pixel as the bilinear interpolation of the four closest pixels from the source. 
+/// If outside the bounds, it doesn't change the destination
+/// \ingroup ImageAlgorithms
+struct bilinear_sampler {};
+
+template <typename DstP, typename SrcView, typename F>
+bool sample(bilinear_sampler, const SrcView& src, const point2<F>& p, DstP& result) {
+    typedef typename SrcView::value_type SrcP;
+    point2<std::ptrdiff_t> p0(ifloor(p)); // the closest integer coordinate top left from p
+    point2<F> frac(p.x-p0.x, p.y-p0.y);
+    if (p0.x < 0 || p0.y < 0 || p0.x>=src.width() || p0.y>=src.height()) return false;
+
+    pixel<F,devicen_layout_t<num_channels<SrcView>::value> > mp(0);                     // suboptimal
+    typename SrcView::xy_locator loc=src.xy_at(p0.x,p0.y);
+
+    if (p0.x+1<src.width()) {
+        if (p0.y+1<src.height()) {
+            // most common case - inside the image, not on the last row or column
+            detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(*loc,      (1-frac.x)*(1-frac.y),mp);
+            detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(loc.x()[1],   frac.x *(1-frac.y),mp);
+            ++loc.y();
+            detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(*loc,      (1-frac.x)*   frac.y ,mp);
+            detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(loc.x()[1],   frac.x *   frac.y ,mp);
+        } else {
+            // on the last row, but not the bottom-right corner pixel
+            detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(*loc,      (1-frac.x),mp);
+            detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(loc.x()[1],   frac.x ,mp);
+        }
+    } else {
+        if (p0.y+1<src.height()) {
+            // on the last column, but not the bottom-right corner pixel
+            detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(*loc,      (1-frac.y),mp);
+            ++loc.y();
+            detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(*loc,         frac.y ,mp);
+        } else {
+            // the bottom-right corner pixel
+            detail::add_dst_mul_src<SrcP,F,pixel<F,devicen_layout_t<num_channels<SrcView>::value> > >()(*loc,1,mp);
+        }
+    }
+
+    // Convert from floating point average value to the source type
+    SrcP src_result;
+    cast_pixel(mp,src_result);
+
+    color_convert(src_result, result);
+    return true;
+}
+
+} }  // namespace boost::gil
+
+#endif
diff --git a/boost/intrusive/detail/has_member_function_callable_with.hpp b/boost/intrusive/detail/has_member_function_callable_with.hpp
index be4a015..d86231c 100644
--- a/boost/intrusive/detail/has_member_function_callable_with.hpp
+++ b/boost/intrusive/detail/has_member_function_callable_with.hpp
@@ -195,6 +195,8 @@
             static const bool value = false;
          };
 
+         #ifdef BOOST_NO_CXX11_DECLTYPE
+
          //Special case for 0 args
          template< class F
                , std::size_t N =
@@ -215,14 +217,21 @@
             BOOST_PP_CAT(zeroarg_checker_, BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME)(int);
          };
 
+         #endif   //#ifdef BOOST_NO_CXX11_DECLTYPE
+
          template<typename Fun>
          struct BOOST_PP_CAT(BOOST_PP_CAT(has_member_function_callable_with_, BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME),_impl)
             <Fun, true>
          {
+            #ifndef BOOST_NO_CXX11_DECLTYPE
+            template<class U, class V = decltype(boost::move_detail::declval<Fun>().BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME()) >
+            static boost_intrusive_has_member_function_callable_with::yes_type Test(Fun*);
+            #else
             template<class U>
-            static BOOST_PP_CAT(zeroarg_checker_, BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME)
+               static BOOST_PP_CAT(zeroarg_checker_, BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME)
                <U> Test(BOOST_PP_CAT(zeroarg_checker_, BOOST_INTRUSIVE_HAS_MEMBER_FUNCTION_CALLABLE_WITH_FUNCNAME)<U>*);
-
+            #endif
+   
             template <class U>
             static boost_intrusive_has_member_function_callable_with::no_type Test(...);
 
diff --git a/boost/mpl/vector/vector100.hpp b/boost/mpl/vector/vector100.hpp
new file mode 100644
index 0000000..3343624
--- /dev/null
+++ b/boost/mpl/vector/vector100.hpp
@@ -0,0 +1,18 @@
+
+#ifndef BOOST_MPL_VECTOR_VECTOR100_HPP_INCLUDED
+#define BOOST_MPL_VECTOR_VECTOR100_HPP_INCLUDED
+
+#   include <boost/mpl/vector/vector50.hpp>
+#   include <boost/mpl/aux_/config/typeof.hpp>
+#   include <boost/mpl/aux_/config/ctps.hpp>
+#   include <boost/preprocessor/iterate.hpp>
+
+namespace boost { namespace mpl {
+
+#   define BOOST_PP_ITERATION_PARAMS_1 \
+    (3,(51, 100, <boost/mpl/vector/aux_/numbered.hpp>))
+#   include BOOST_PP_ITERATE()
+
+}}
+
+#endif // BOOST_MPL_VECTOR_VECTOR100_HPP_INCLUDED
diff --git a/boost/mpl/vector/vector100_c.hpp b/boost/mpl/vector/vector100_c.hpp
new file mode 100644
index 0000000..541c548
--- /dev/null
+++ b/boost/mpl/vector/vector100_c.hpp
@@ -0,0 +1,19 @@
+
+#ifndef BOOST_MPL_VECTOR_VECTOR100_C_HPP_INCLUDED
+#define BOOST_MPL_VECTOR_VECTOR100_C_HPP_INCLUDED
+
+#   include <boost/mpl/vector/vector50_c.hpp>
+#   include <boost/mpl/vector/vector100.hpp>
+#   include <boost/mpl/aux_/config/typeof.hpp>
+#   include <boost/mpl/aux_/config/ctps.hpp>
+#   include <boost/preprocessor/iterate.hpp>
+
+namespace boost { namespace mpl {
+
+#   define BOOST_PP_ITERATION_PARAMS_1 \
+    (3,(51, 100, <boost/mpl/vector/aux_/numbered_c.hpp>))
+#   include BOOST_PP_ITERATE()
+
+}}
+
+#endif // BOOST_MPL_VECTOR_VECTOR100_C_HPP_INCLUDED
diff --git a/boost/range/algorithm/transform.hpp b/boost/range/algorithm/transform.hpp
index fb03441..14fd2f8 100644
--- a/boost/range/algorithm/transform.hpp
+++ b/boost/range/algorithm/transform.hpp
@@ -58,6 +58,7 @@ namespace boost
                        OutputIterator                       out,
                        BinaryFunction                       fn)
         {
+            boost::ignore_unused_variable_warning(last2);
             for (; first1 != last1; ++first1, ++first2)
             {
                 BOOST_ASSERT( first2 != last2 );
diff --git a/boost/units/quantity.hpp b/boost/units/quantity.hpp
index 3cd6682..9c54897 100644
--- a/boost/units/quantity.hpp
+++ b/boost/units/quantity.hpp
@@ -280,6 +280,16 @@ class quantity
         ///< can divide a quantity by a scalar value_type if divide_typeof_helper<value_type,value_type>::type is convertible to value_type
         this_type& operator/=(const value_type& source) { val_ /= source; return *this; }
     
+        this_type& operator++()
+        { ++val_; return *this; }
+        this_type operator++(int)
+        { this_type rval = *this; val_++; return rval; }
+
+        this_type& operator--()
+        { --val_; return *this; }
+        this_type operator--(int)
+        { this_type rval = *this; val_--; return rval; }
+
         /// Construct quantity directly from @c value_type (potentially dangerous).
         static this_type from_value(const value_type& val)  { return this_type(val, 0); }
 
@@ -1175,6 +1185,12 @@ operator/(const quantity<Unit1,X>& lhs,
     return type::from_value(lhs.value()/rhs.value());
 }
 
+/// runtime operator%
+template <class Unit, class X, class Y>
+inline
+quantity<Unit,X> operator%(const quantity<Unit,X>& lhs, const Y& rhs)
+{ return quantity<Unit,X>::from_value(lhs.value() % rhs); }
+
 /// runtime operator==
 template<class Unit,
          class X,
diff --git a/libs/filesystem/src/operations.cpp b/libs/filesystem/src/operations.cpp
index a1504b5..e06f97f 100644
--- a/libs/filesystem/src/operations.cpp
+++ b/libs/filesystem/src/operations.cpp
@@ -1409,7 +1409,7 @@ namespace detail
     //  - See the fchmodat() Linux man page:
     //   "http://man7.org/linux/man-pages/man2/fchmodat.2.html"
 #   if defined(AT_FDCWD) && defined(AT_SYMLINK_NOFOLLOW) \
-      && !(defined(__SUNPRO_CC) || defined(sun)) \
+      && !(defined(__SUNPRO_CC) || defined(sun) || defined(__sun) || defined(__sun__)) \
       && !(defined(linux) || defined(__linux) || defined(__linux__))
       if (::fchmodat(AT_FDCWD, p.c_str(), mode_cast(prms),
            !(prms & symlink_perms) ? 0 : AT_SYMLINK_NOFOLLOW))
diff --git a/libs/intrusive/test/has_member_function_callable_with.cpp b/libs/intrusive/test/has_member_function_callable_with.cpp
index 96b822e..0036c3f 100644
--- a/libs/intrusive/test/has_member_function_callable_with.cpp
+++ b/libs/intrusive/test/has_member_function_callable_with.cpp
@@ -68,7 +68,7 @@ class has_member_function_named_func
 
 }}}
 
-#if !defined(BOOST_CONTAINER_PERFECT_FORWARDING)
+#if !defined(BOOST_INTRUSIVE_PERFECT_FORWARDING)
 
    namespace boost{
    namespace intrusive{
@@ -259,7 +259,7 @@ class has_member_function_named_func
 
    }}}
 
-#else
+#else //#if !defined(BOOST_INTRUSIVE_PERFECT_FORWARDING)
 
    namespace boost{
    namespace intrusive{
@@ -283,6 +283,7 @@ class has_member_function_named_func
    namespace intrusive{
    namespace intrusive_detail{
 
+   #ifdef BOOST_NO_CXX11_DECLTYPE
    template<class F, std::size_t N = sizeof(boost::move_detail::declval<F>().func(), 0)>
    struct zeroarg_checker_func
    {
@@ -299,12 +300,19 @@ class has_member_function_named_func
       zeroarg_checker_func(int);
    };
 
+   #endif   //BOOST_NO_CXX11_DECLTYPE
+
    template<typename Fun>
    struct has_member_function_callable_with_func_impl
       <Fun, true>
    {
-      template<class U>
-      static zeroarg_checker_func<U> Test(zeroarg_checker_func<U>*);
+      #ifndef BOOST_NO_CXX11_DECLTYPE
+      template<class U, class V = decltype(boost::move_detail::declval<Fun>().func()) >
+         static boost_intrusive_has_member_function_callable_with::yes_type Test(U*);
+      #else
+         template<class U>
+         static zeroarg_checker_func<U> Test(zeroarg_checker_func<U>*);
+      #endif
 
       template <class U>
       static has_member_function_callable_with::no_type Test(...);
@@ -356,7 +364,7 @@ class has_member_function_named_func
 
    }}}
 
-#endif
+#endif   //#if !defined(BOOST_INTRUSIVE_PERFECT_FORWARDING)
 
 struct functor
 {
diff --git a/libs/log/src/dump_avx2.cpp b/libs/log/src/dump_avx2.cpp
index 92cacbd..fa1ca3f 100644
--- a/libs/log/src/dump_avx2.cpp
+++ b/libs/log/src/dump_avx2.cpp
@@ -205,7 +205,7 @@ BOOST_FORCEINLINE void dump_data_avx2(const void* data, std::size_t size, std::b
             __m256i mm_input = _mm256_load_si256(reinterpret_cast< const __m256i* >(p));
             __m256i mm_output1, mm_output2, mm_output3;
             dump_pack(mm_char_10_to_a, mm_input, mm_output1, mm_output2, mm_output3);
-            store_characters_x3(mm_output1, mm_output2, mm_output3, buf);
+            store_characters_x3(mm_output1, mm_output2, mm_output3, b);
         }
 
         _mm256_zeroall(); // need to zero all ymm registers to avoid register spills/restores the compler generates around the function call
